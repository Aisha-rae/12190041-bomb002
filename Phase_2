lab02@lab02-OptiPlex-3040:~/Desktop/12190041/Assignment 1/bomb002$ gdb bomb
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from bomb...
(gdb) break phase_1
Breakpoint 1 at 0x400e8d
(gdb) break explode_bomb
Breakpoint 2 at 0x401438
(gdb) run
Starting program: /home/lab02/Desktop/12190041/Assignment 1/bomb002/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
hello world

Breakpoint 1, 0x0000000000400e8d in phase_1 ()
(gdb) disas
Dump of assembler code for function phase_1:
=> 0x0000000000400e8d <+0>:	sub    $0x8,%rsp
   0x0000000000400e91 <+4>:	mov    $0x4023cc,%esi
   0x0000000000400e96 <+9>:	callq  0x401339 <strings_not_equal>
   0x0000000000400e9b <+14>:	test   %eax,%eax
   0x0000000000400e9d <+16>:	je     0x400ea4 <phase_1+23>
   0x0000000000400e9f <+18>:	callq  0x401438 <explode_bomb>
   0x0000000000400ea4 <+23>:	add    $0x8,%rsp
   0x0000000000400ea8 <+27>:	retq   
End of assembler dump.
(gdb) ni
0x0000000000400e91 in phase_1 ()
(gdb) ni
0x0000000000400e96 in phase_1 ()
(gdb) disas
Dump of assembler code for function phase_1:
   0x0000000000400e8d <+0>:	sub    $0x8,%rsp
   0x0000000000400e91 <+4>:	mov    $0x4023cc,%esi
=> 0x0000000000400e96 <+9>:	callq  0x401339 <strings_not_equal>
   0x0000000000400e9b <+14>:	test   %eax,%eax
   0x0000000000400e9d <+16>:	je     0x400ea4 <phase_1+23>
   0x0000000000400e9f <+18>:	callq  0x401438 <explode_bomb>
   0x0000000000400ea4 <+23>:	add    $0x8,%rsp
   0x0000000000400ea8 <+27>:	retq   
End of assembler dump.
(gdb) i r
rax            0x6037a0            6305696
rbx            0x4021f0            4202992
rcx            0xb                 11
rdx            0x6037a0            6305696
rsi            0x4023cc            4203468
rdi            0x6037a0            6305696
rbp            0x0                 0x0
rsp            0x7fffffffde60      0x7fffffffde60
r8             0x6037a0            6305696
r9             0x7c                124
r10            0xfffffffffffff6ed  -2323
r11            0x7ffff7dfa400      140737352016896
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400e96            0x400e96 <phase_1+9>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni
0x0000000000400e9b in phase_1 ()
(gdb) i r
rax            0x1                 1
rbx            0x4021f0            4202992
rcx            0xb                 11
rdx            0x1                 1
rsi            0x4023cc            4203468
rdi            0x4023e9            4203497
rbp            0x0                 0x0
rsp            0x7fffffffde60      0x7fffffffde60
r8             0x6037a0            6305696
r9             0x7c                124
r10            0xfffffffffffff6ed  -2323
r11            0x7ffff7dfa400      140737352016896
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400e9b            0x400e9b <phase_1+14>
eflags         0x297               [ CF PF AF SF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) disas
Dump of assembler code for function phase_1:
   0x0000000000400e8d <+0>:	sub    $0x8,%rsp
   0x0000000000400e91 <+4>:	mov    $0x4023cc,%esi
   0x0000000000400e96 <+9>:	callq  0x401339 <strings_not_equal>
=> 0x0000000000400e9b <+14>:	test   %eax,%eax
   0x0000000000400e9d <+16>:	je     0x400ea4 <phase_1+23>
   0x0000000000400e9f <+18>:	callq  0x401438 <explode_bomb>
   0x0000000000400ea4 <+23>:	add    $0x8,%rsp
   0x0000000000400ea8 <+27>:	retq   
End of assembler dump.
(gdb) x/s  0x1
0x1:	<error: Cannot access memory at address 0x1>
(gdb) x/d  0x1
0x1:	Cannot access memory at address 0x1
(gdb) x/s 0x7fffffffde60
0x7fffffffde60:	""
(gdb) ni
0x0000000000400e9d in phase_1 ()
(gdb) disas
Dump of assembler code for function phase_1:
   0x0000000000400e8d <+0>:	sub    $0x8,%rsp
   0x0000000000400e91 <+4>:	mov    $0x4023cc,%esi
   0x0000000000400e96 <+9>:	callq  0x401339 <strings_not_equal>
   0x0000000000400e9b <+14>:	test   %eax,%eax
=> 0x0000000000400e9d <+16>:	je     0x400ea4 <phase_1+23>
   0x0000000000400e9f <+18>:	callq  0x401438 <explode_bomb>
   0x0000000000400ea4 <+23>:	add    $0x8,%rsp
   0x0000000000400ea8 <+27>:	retq   
End of assembler dump.
(gdb) ni
0x0000000000400e9f in phase_1 ()
(gdb) disas
Dump of assembler code for function phase_1:
   0x0000000000400e8d <+0>:	sub    $0x8,%rsp
   0x0000000000400e91 <+4>:	mov    $0x4023cc,%esi
   0x0000000000400e96 <+9>:	callq  0x401339 <strings_not_equal>
   0x0000000000400e9b <+14>:	test   %eax,%eax
   0x0000000000400e9d <+16>:	je     0x400ea4 <phase_1+23>
=> 0x0000000000400e9f <+18>:	callq  0x401438 <explode_bomb>
   0x0000000000400ea4 <+23>:	add    $0x8,%rsp
   0x0000000000400ea8 <+27>:	retq   
End of assembler dump.
(gdb) i r
rax            0x1                 1
rbx            0x4021f0            4202992
rcx            0xb                 11
rdx            0x1                 1
rsi            0x4023cc            4203468
rdi            0x4023e9            4203497
rbp            0x0                 0x0
rsp            0x7fffffffde60      0x7fffffffde60
r8             0x6037a0            6305696
r9             0x7c                124
r10            0xfffffffffffff6ed  -2323
r11            0x7ffff7dfa400      140737352016896
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400e9f            0x400e9f <phase_1+18>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/s 0x400ea4
0x400ea4 <phase_1+23>:	"H\203\304\b\303USH\203\354(dH\213\004%("
(gdb) x/s 0x4023cc
0x4023cc:	"Public speaking is very easy."
(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) break phase_2
Breakpoint 3 at 0x400ea9
(gdb) break explode_bomb
Breakpoint 4 at 0x401438
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab02/Desktop/12190041/Assignment 1/bomb002/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Public speaking is very easy.
Phase 1 defused. How about the next one?
1 2 3 4 5 6 // From the assembler code we get clue that there is six numbers, then randomly assume the number it will be.

Breakpoint 3, 0x0000000000400ea9 in phase_2 ()
(gdb) disas // We disassemble the code to get more infomation about the code flow.
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp.
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400eaa in phase_2 ()
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400eab in phase_2 ()
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400eaf in phase_2 ()
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400eb8 in phase_2 ()
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400ebd in phase_2 ()
(gdb) ni // We move to seventh line of the code as we can figure out what is happening; the value of register %rsp is moved to %rsi.
0x0000000000400ebf in phase_2 ()
(gdb) disas // We disassemble the code see the line we have reach.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
=> 0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) i r
rax            0x0                 0
rbx            0x4021f0            4202992
rcx            0xb                 11
rdx            0x6037f0            6305776
rsi            0x1                 1
rdi            0x6037f0            6305776
rbp            0x0                 0x0
rsp            0x7fffffffde30      0x7fffffffde30
r8             0x6037f0            6305776
r9             0x0                 0
r10            0xfffffffffffff6ed  -2323
r11            0x246               582
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400ebf            0x400ebf <phase_2+22>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni // we move to next line and we know the value of %rsi is 1. 
0x0000000000400ec2 in phase_2 ()
(gdb) ni // We move to the next code where the %rsp value is compare to hexadecimal value 1:$0x1.
0x0000000000400ec7 in phase_2 ()
(gdb)  i r // WE check the vlaue for %rsp.
rax            0x6                 6
rbx            0x4021f0            4202992
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x0                 0x0
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400ec7            0x400ec7 <phase_2+30>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/d 0x7fffffffde30 // We show the value of %rsp into decimal and we find out it is 1.
0x7fffffffde30:	1
(gdb) ni // We move to next line.
0x0000000000400ecb in phase_2 ()
(gdb) disas // Disassemble the code to see the line we have reached.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
=> 0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni //We move to next line of code.
0x0000000000400ed2 in phase_2 ()
(gdb) disas // We can see from here that the code skip the explode_bomb call function, so we can say that the integer "1" is a valid integer.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
=> 0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni //We move to next line
0x0000000000400ed5 in phase_2 ()
(gdb) ni //We move to next line.
0x0000000000400eda in phase_2 ()
(gdb) disas //We disasmble the code to see the code flow.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
=> 0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) i r //From here we see the rax value is 6.
rax            0x6                 6
rbx            0x7fffffffde30      140737488346672
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400eda            0x400eda <phase_2+49>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni // We move to next line.
0x0000000000400edc in phase_2 ()
(gdb) disas // We keep track of the code. 
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
=> 0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) i r // Here we can see rax value is 1 since %rbx value is moved to %eax
rax            0x1                 1
rbx            0x7fffffffde30      140737488346672
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400edc            0x400edc <phase_2+51>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni //We move to next line of code
0x0000000000400ede in phase_2 ()
(gdb) i r //Here we can see that the rax value is two since %eax(1) and %eax(1) value is added.
rax            0x2                 2
rbx            0x7fffffffde30      140737488346672
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400ede            0x400ede <phase_2+53>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni //We move to next line
0x0000000000400ee1 in phase_2 ()
(gdb) disas //Keep track of code line execution. We then compare where the value %eax(2) is equal to %0x4(%rbx)(2).
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
=> 0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni //We move to next line.
0x0000000000400ee8 in phase_2 ()
(gdb) disas //Here we we can see they are equal and the explode_bomb function is not called.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
=> 0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) i r //For next line of code we need to know the value of rbx.
rax            0x2                 2
rbx            0x7fffffffde30      140737488346672
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400ee8            0x400ee8 <phase_2+63>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/d 140737488346672 // To see the value of rbx we turn the value into decimal form.
0x7fffffffde30:	1 // we can see it is 1.
(gdb) ni //Then we move to next line of code.
0x0000000000400eec in phase_2 ()
(gdb) i r //From here we can see changes in address of rbx.
rax            0x2                 2
rbx            0x7fffffffde34      140737488346676
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400eec            0x400eec <phase_2+67>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/d 140737488346676 // We convert the value of rbx to decimal.
0x7fffffffde34:	2 // It is 2.
(gdb) ni.//We move to next line of code.
0x0000000000400eef in phase_2 ()
(gdb) disas //Here we can see the value of rbx and rbp is comparing.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
=> 0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) x/d 0x7fffffffde44 //We know the value of rbx but we don't know the value of rbp;we convert the value to decimal number.
0x7fffffffde44:	6 // It is 6.
(gdb) ni //We move to next line of code.
0x0000000000400eda in phase_2 ()
(gdb) disas //Since it is not equal, it move to line 49.From here we can see that the code have for loop and integer 2 is valid integer.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
=> 0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni// We move to next line.
0x0000000000400edc in phase_2 ()
(gdb) ni// We move to next line.
0x0000000000400ede in phase_2 ()
(gdb) disas //From here, we can see that the both %eax(2) is added and now %eax value is 4. 
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
=> 0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) i r //We can see the value of rax has change.
rax            0x4                 4
rbx            0x7fffffffde34      140737488346676
rcx            0x0                 0
rdx            0x7fffffffde44      140737488346692
rsi            0x0                 0
rdi            0x7fffffffd7c0      140737488345024
rbp            0x7fffffffde44      0x7fffffffde44
rsp            0x7fffffffde30      0x7fffffffde30
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf60      140737488346976
r14            0x0                 0
r15            0x0                 0
rip            0x400ede            0x400ede <phase_2+53>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) ni // We move to next line.
0x0000000000400ee1 in phase_2 ()
(gdb) disas /From here, we can see that the value are being compare.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
=> 0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
   0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump.
(gdb) ni //We move to next line.
0x0000000000400ee3 in phase_2 ()
(gdb) disas //Since they are not equal, the explode_bomb function is called.
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40145a <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x1,(%rsp)
   0x0000000000400ecb <+34>:	je     0x400ed2 <phase_2+41>
   0x0000000000400ecd <+36>:	callq  0x401438 <explode_bomb>
   0x0000000000400ed2 <+41>:	mov    %rsp,%rbx
   0x0000000000400ed5 <+44>:	lea    0x14(%rsp),%rbp
   0x0000000000400eda <+49>:	mov    (%rbx),%eax
   0x0000000000400edc <+51>:	add    %eax,%eax
   0x0000000000400ede <+53>:	cmp    %eax,0x4(%rbx)
   0x0000000000400ee1 <+56>:	je     0x400ee8 <phase_2+63>
=> 0x0000000000400ee3 <+58>:	callq  0x401438 <explode_bomb>
   0x0000000000400ee8 <+63>:	add    $0x4,%rbx
   0x0000000000400eec <+67>:	cmp    %rbp,%rbx
   0x0000000000400eef <+70>:	jne    0x400eda <phase_2+49>
   0x0000000000400ef1 <+72>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef6 <+77>:	xor    %fs:0x28,%rax
   0x0000000000400eff <+86>:	je     0x400f06 <phase_2+93>
   0x0000000000400f01 <+88>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f06 <+93>:	add    $0x28,%rsp
   0x0000000000400f0a <+97>:	pop    %rbx
   0x0000000000400f0b <+98>:	pop    %rbp
   0x0000000000400f0c <+99>:	retq   
End of assembler dump. //From this, we can tell that the three numbers are 1 2 4. We can see the hint for next three numbers. By looking at pattern, the next three
numbers would be 8, 16 and 32.
(gdb) delete //Delete all the breakpoints so phase_2 function can execute.
Delete all breakpoints? (y or n) y
(gdb) break phase_2 
Breakpoint 5 at 0x400ea9
(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) break phase_3 //set break point on phase 3 so it can only be one to execute.
Breakpoint 6 at 0x400f0d
(gdb) break explode_bomb //set break point on explode_bomb function so it won't explode if the input is wrong.
Breakpoint 7 at 0x401438
(gdb) run //Execute the function of phase_2
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab02/Desktop/12190041/Assignment 1/bomb002/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Public speaking is very easy. //Enter the answer for phase_1
Phase 1 defused. How about the next one?
1 2 4 8 16 32 //Then enter the six numbers as answer.
That's number 2.  Keep going! //The bomb of phase_2 has been defuse.
try 1
